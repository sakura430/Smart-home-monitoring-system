#include "header.h"

void control_task(void *arg) {
    int switch_command;
    
    while (1) {
        // 等待切换命令
        if (xQueueReceive(xTaskStatusQueue, &switch_command, portMAX_DELAY) == pdPASS) {
            switch (switch_command) {
                case 0: // 切换到本地模式
                    if (!local_storage_mode) {
                        local_storage_mode = 1;
                        PrintToUTools("Switching to local storage\r\n");
                        vTaskSuspend(handle1);
                        vTaskResume(handle2);
                    }
                    break;
                case 1: // 切换回网络模式
                    if (local_storage_mode) {
                        local_storage_mode = 0;
                        PrintToUTools("Switching back to network\r\n");
                        vTaskSuspend(handle2);
                        vTaskResume(handle1);
                    }
                    break;
            }
        }
    }
}

void task2(void *arg) {
    vTaskSuspend(handle2);
    OLED_UpdateDisplay("task2 start");
    PrintToUTools("task2 start\r\n");
    W25Q64_Erase_Sector(0x000000); // 擦除扇区0
    W25Q64_Erase_Sector(0x001000);// 擦除扇区1
    W25Q64_Erase_Sector(0x002000);// 擦除扇区2
    int base_address = 0x000000;
    int num = 0;

    while (1) {
		IWDG_ReloadCounter();
        // 每处理10个数据点检查一次网络状态
        if (num >= 10) {
            num = 0;
            // 尝试连接到WiFi
            if (quick_wifi_check()) {
                int switch_command = 1; // 切换到task1的信号
                xQueueSend(xTaskStatusQueue, &switch_command, 0);

                // 进入等待切换状态
                OLED_UpdateDisplay("Network back!");
                PrintToUTools("Network restored!\r\n");

                // 等待主控任务处理切换
                vTaskSuspend(handle2);
            }
        }
        LED_Control(GREEN, LED_FAST_BLINK);
        char buf[20] = {0};
        if (num % 2 == 0) {
            uint16_t  ret  =  AD_GetValue(ADC_Channel_1);//光敏电阻

                            if (ret > LDR_MAX) {
                                LED_Control(BLUE, LED_ON);
                            } else {
                                LED_Control(BLUE, LED_OFF);
                            }
            sprintf(buf, "++LDR:%u,%d", ret, num);
        } else {
            uint16_t  ret  =  AD_GetValue(ADC_Channel_0);//红外线感应

                            if (ret > IR_MAX) {
                                Buzzer_Control(ON);
                                LED_Control(RED, LED_FAST_BLINK);
                            } else {
                                LED_Control(RED, LED_OFF);
                               Buzzer_Control(OFF);
                            }
            sprintf(buf, "++IR:%u,%d", ret, num);
        }

        PrintToUTools("%s\r\n", buf);
        W25Q64_Write_String(base_address, buf, 20);
        OLED_UpdateDisplay(buf);
        base_address += 20;
        memset(buf, 0, sizeof(buf));

        num++;

        // 循环地址空间
        if (base_address >= 0x003000) {
            base_address = 0x000000;
        }

        Delay_Ms(1000);
    }
}

void task(void *arg) {
    wifi_connect();//wifi连接
	tcp_connect();//tcp连接
    esp01s_open();//开启透传模式
    int num = 0;
    LED_Control(GREEN, LED_SLOW_BLINK);
    while (1) { //发送数据
		IWDG_ReloadCounter();
		char buf[20] = {0};
        if (num % 2 == 0) {
            uint16_t  ret  =  AD_GetValue(ADC_Channel_1);//光敏电阻
            if (ret > LDR_MAX) {
                LED_Control(BLUE, LED_ON);
            } else {
                LED_Control(BLUE, LED_OFF);
            }
            tcp_send_data("LDR", ret);
            sprintf(buf, "LDR:%u,%d", ret, num);
        } else {
            uint16_t  ret  =  AD_GetValue(ADC_Channel_0);//红外线感应
            if (ret > IR_MAX) {
                Buzzer_Control(ON);
                LED_Control(RED, LED_FAST_BLINK);
                LED_Control(GREEN, LED_ON);
            } else {
                LED_Control(RED, LED_OFF);
                Buzzer_Control(OFF);
            }
            tcp_send_data("IR", ret);
            sprintf(buf, "IR:%u,%d", ret, num);
        }
        PrintToUTools("%s", buf);
        OLED_UpdateDisplay(buf);
        Delay_Ms(1000);
        num++;
        if (num == 50) {
            esp01s_close();
            LED_Control(GREEN, LED_ON);
        }
    }
}

int main(void) {
    OLED_Init();
    AD_Init();
    USART1_NVIC_Init();
    USART2_NVIC_Init();
    USART3_NVIC_Init();
    LED_Init();
    TIM_Init();
    Buzzer_Init();
    SPI1_Init();
    Delay_Ms(2000);
	IWDG_Init();
	if (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) != RESET) {
		OLED_UpdateDisplay("reset by IWDG");
		RCC_ClearFlag();
	} else {
		OLED_UpdateDisplay("Normal boot");
	}
    LED_Control(GREEN, LED_ON); //上电绿灯常亮
    LED_Control(RED, LED_SLOW_BLINK); //红灯慢闪等待wifi
    OLED_UpdateDisplay("PleaseWait");

    queueUTools = xQueueCreate(MAX_SIZE, sizeof(char));
    queueESP01s = xQueueCreate(MAX_SIZE, sizeof(char));
    queueHC05 = xQueueCreate(MAX_SIZE, sizeof(char));
    QueueSet = xQueueCreateSet(MAX_SIZE * 3);
    xQueueAddToSet(queueUTools, QueueSet);
    xQueueAddToSet(queueESP01s, QueueSet);
    xQueueAddToSet(queueHC05, QueueSet);
    xTaskStatusQueue = xQueueCreate(1, sizeof(int));
    xTaskCreate(task, "task", 256, NULL, 3, &handle1);
    xTaskCreate(task2, "task2", 256, NULL, 2, &handle2);
	xTaskCreate(control_task, "Control", 128, NULL, 4, NULL);
    vTaskStartScheduler();

    while (1) {
    }
}
